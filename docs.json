[{"name":"Head","comment":" This module contains low-level functions for building up\nvalues that will be rendered into the page's `<head>` tag\nwhen you run `elm-pages build`. Most likely the `Head.Seo` module\nwill do everything you need out of the box, and you will just need to import `Head`\nso you can use the `Tag` type in your type annotations.\n\nBut this module might be useful if you have a special use case, or if you are\nwriting a plugin package to extend `elm-pages`.\n\n@docs Tag, metaName, metaProperty\n@docs rssLink, sitemapLink\n\n\n## `AttributeValue`s\n\n@docs AttributeValue\n@docs currentPageFullUrl, fullImageUrl, fullPageUrl, raw\n\n\n## Functions for use by generated code\n\n@docs toJson, canonicalLink\n\n","unions":[{"name":"AttributeValue","comment":" Values, such as between the `<>`'s here:\n\n```html\n<meta name=\"<THIS IS A VALUE>\" content=\"<THIS IS A VALUE>\" />\n```\n\n","args":["pathKey"],"cases":[]},{"name":"Tag","comment":" Values that can be passed to the generated `Pages.application` config\nthrough the `head` function.\n","args":["pathKey"],"cases":[]}],"aliases":[],"values":[{"name":"canonicalLink","comment":" It's recommended that you use the `Seo` module helpers, which will provide this\nfor you, rather than directly using this.\n\nExample:\n\n    Head.canonicalLink \"https://elm-pages.com\"\n\n","type":"Maybe.Maybe (Pages.PagePath.PagePath pathKey) -> Head.Tag pathKey"},{"name":"currentPageFullUrl","comment":" Create an `AttributeValue` representing the current page's full url.\n","type":"Head.AttributeValue pathKey"},{"name":"fullImageUrl","comment":" Create an `AttributeValue` from an `ImagePath`.\n","type":"Pages.ImagePath.ImagePath pathKey -> Head.AttributeValue pathKey"},{"name":"fullPageUrl","comment":" Create an `AttributeValue` from a `PagePath`.\n","type":"Pages.PagePath.PagePath pathKey -> Head.AttributeValue pathKey"},{"name":"metaName","comment":" Example:\n\n    metaName\n        [ ( \"name\", \"twitter:card\" )\n        , ( \"content\", \"summary_large_image\" )\n        ]\n\nResults in `<meta name=\"twitter:card\" content=\"summary_large_image\" />`\n\n","type":"String.String -> Head.AttributeValue pathKey -> Head.Tag pathKey"},{"name":"metaProperty","comment":" Example:\n\n    Head.metaProperty \"fb:app_id\" (Head.raw \"123456789\")\n\nResults in `<meta property=\"fb:app_id\" content=\"123456789\" />`\n\n","type":"String.String -> Head.AttributeValue pathKey -> Head.Tag pathKey"},{"name":"raw","comment":" Create a raw `AttributeValue` (as opposed to some kind of absolute URL).\n","type":"String.String -> Head.AttributeValue pathKey"},{"name":"rssLink","comment":" Add a link to the site's RSS feed.\n\nExample:\n\n    rssLink \"/feed.xml\"\n\n```html\n<link rel=\"alternate\" type=\"application/rss+xml\" href=\"/rss.xml\">\n```\n\n","type":"String.String -> Head.Tag pathKey"},{"name":"sitemapLink","comment":" Add a link to the site's RSS feed.\n\nExample:\n\n    sitemapLink \"/feed.xml\"\n\n```html\n<link rel=\"sitemap\" type=\"application/xml\" href=\"/sitemap.xml\">\n```\n\n","type":"String.String -> Head.Tag pathKey"},{"name":"toJson","comment":" Feel free to use this, but in 99% of cases you won't need it. The generated\ncode will run this for you to generate your `manifest.json` file automatically!\n","type":"String.String -> String.String -> Head.Tag pathKey -> Json.Encode.Value"}],"binops":[]},{"name":"Head.Seo","comment":" <https://ogp.me/#>\n<https://developers.facebook.com/docs/sharing/opengraph>\n\nThis module encapsulates some of the best practices for SEO for your site.\n\n`elm-pages` will pre-render each of the static pages (in your `content` directory) so that\nweb crawlers can efficiently and accurately process it. The functions in this module are for use\nwith the `head` function that you pass to your Pages config (`Pages.application`).\n\n    import Date\n    import Head\n    import Head.Seo as Seo\n\n\n    -- justinmimbs/date package\n    type alias ArticleMetadata =\n        { title : String\n        , description : String\n        , published : Date\n        , author : Data.Author.Author\n        }\n\n    head : ArticleMetadata -> List (Head.Tag Pages.PathKey)\n    head articleMetadata =\n        Seo.summaryLarge\n            { canonicalUrlOverride = Nothing\n            , siteName = \"elm-pages\"\n            , image =\n                { url = Pages.images.icon\n                , alt = articleMetadata.description\n                , dimensions = Nothing\n                , mimeType = Nothing\n                }\n            , description = articleMetadata.description\n            , locale = Nothing\n            , title = articleMetadata.title\n            }\n            |> Seo.article\n                { tags = []\n                , section = Nothing\n                , publishedTime = Just (Date.toIsoString articleMetadata.published)\n                , modifiedTime = Nothing\n                , expirationTime = Nothing\n                }\n\n@docs Common, Image, article, audioPlayer, profile, song, summary, summaryLarge, videoPlayer, website\n\n","unions":[],"aliases":[{"name":"Common","comment":" These fields apply to any type in the og object types\nSee <https://ogp.me/#metadata> and <https://ogp.me/#optional>\n\nSkipping this for now, if there's a use case I can add it in:\n\n  - og:determiner - The word that appears before this object's title in a sentence. An enum of (a, an, the, \"\", auto). If auto is chosen, the consumer of your data should chose between \"a\" or \"an\". Default is \"\" (blank).\n\n","args":["pathKey"],"type":"{ title : String.String, image : Head.Seo.Image pathKey, canonicalUrlOverride : Maybe.Maybe (Pages.PagePath.PagePath pathKey), description : String.String, siteName : String.String, audio : Maybe.Maybe Head.Seo.Audio, video : Maybe.Maybe Head.Seo.Video, locale : Maybe.Maybe Head.Seo.Locale, alternateLocales : List.List Head.Seo.Locale, twitterCard : Head.Twitter.TwitterCard pathKey }"},{"name":"Image","comment":" See <https://ogp.me/#structured>\n","args":["pathKey"],"type":"{ url : Pages.ImagePath.ImagePath pathKey, alt : String.String, dimensions : Maybe.Maybe { width : Basics.Int, height : Basics.Int }, mimeType : Maybe.Maybe Head.Seo.MimeType }"}],"values":[{"name":"article","comment":" See <https://ogp.me/#type_article>\n","type":"{ tags : List.List String.String, section : Maybe.Maybe String.String, publishedTime : Maybe.Maybe Head.Seo.Iso8601DateTime, modifiedTime : Maybe.Maybe Head.Seo.Iso8601DateTime, expirationTime : Maybe.Maybe Head.Seo.Iso8601DateTime } -> Head.Seo.Common pathKey -> List.List (Head.Tag pathKey)"},{"name":"audioPlayer","comment":" Will be displayed as a Player card in twitter\nSee: <https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/player-card>\n\nOpenGraph audio will also be included.\nThe options will also be used to build up the appropriate OpenGraph `<meta>` tags.\n\n","type":"{ canonicalUrlOverride : Maybe.Maybe (Pages.PagePath.PagePath pathKey), siteName : String.String, image : Head.Seo.Image pathKey, description : String.String, title : String.String, audio : Head.Seo.Audio, locale : Maybe.Maybe Head.Seo.Locale } -> Head.Seo.Common pathKey"},{"name":"profile","comment":" See <https://ogp.me/#type_profile>\n","type":"{ firstName : String.String, lastName : String.String, username : Maybe.Maybe String.String } -> Head.Seo.Common pathKey -> List.List (Head.Tag pathKey)"},{"name":"song","comment":" See <https://ogp.me/#type_music.song>\n","type":"Head.Seo.Common pathKey -> { duration : Maybe.Maybe Basics.Int, album : Maybe.Maybe Basics.Int, disc : Maybe.Maybe Basics.Int, track : Maybe.Maybe Basics.Int } -> List.List (Head.Tag pathKey)"},{"name":"summary","comment":" Will be displayed as a large card in twitter\nSee: <https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/summary>\n\nThe options will also be used to build up the appropriate OpenGraph `<meta>` tags.\n\nNote: You cannot include audio or video tags with summaries.\nIf you want one of those, use `audioPlayer` or `videoPlayer`\n\n","type":"{ canonicalUrlOverride : Maybe.Maybe (Pages.PagePath.PagePath pathKey), siteName : String.String, image : Head.Seo.Image pathKey, description : String.String, title : String.String, locale : Maybe.Maybe Head.Seo.Locale } -> Head.Seo.Common pathKey"},{"name":"summaryLarge","comment":" Will be displayed as a large card in twitter\nSee: <https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/summary-card-with-large-image>\n\nThe options will also be used to build up the appropriate OpenGraph `<meta>` tags.\n\nNote: You cannot include audio or video tags with summaries.\nIf you want one of those, use `audioPlayer` or `videoPlayer`\n\n","type":"{ canonicalUrlOverride : Maybe.Maybe (Pages.PagePath.PagePath pathKey), siteName : String.String, image : Head.Seo.Image pathKey, description : String.String, title : String.String, locale : Maybe.Maybe Head.Seo.Locale } -> Head.Seo.Common pathKey"},{"name":"videoPlayer","comment":" Will be displayed as a Player card in twitter\nSee: <https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/player-card>\n\nOpenGraph video will also be included.\nThe options will also be used to build up the appropriate OpenGraph `<meta>` tags.\n\n","type":"{ canonicalUrlOverride : Maybe.Maybe (Pages.PagePath.PagePath pathKey), siteName : String.String, image : Head.Seo.Image pathKey, description : String.String, title : String.String, video : Head.Seo.Video, locale : Maybe.Maybe Head.Seo.Locale } -> Head.Seo.Common pathKey"},{"name":"website","comment":" <https://ogp.me/#type_website>\n","type":"Head.Seo.Common pathKey -> List.List (Head.Tag pathKey)"}],"binops":[]},{"name":"Pages.Directory","comment":" The `Directory` type can be used to get the children of a given directory,\ncheck if a `PagePath` is within a `Directory`, or get the index page corresponding\nto the directory (if it is a `Directory pathKey WithIndex`).\n\n@docs Directory\n\n@docs includes\n\n\n## Getting a `Directory`'s corresponding index page\n\n@docs indexPath, WithIndex, WithoutIndex\n\n\n## Functions for use by generated code\n\n@docs withIndex, withoutIndex\n\n","unions":[{"name":"Directory","comment":" Represents a known Directory within your `content` folder\nof your `elm-pages` site.\n","args":["key","hasIndex"],"cases":[]},{"name":"WithIndex","comment":" Used for a `Directory` that has an index path directly at that path. See\n`Directory.indexPath`.\n","args":[],"cases":[]},{"name":"WithoutIndex","comment":" Used for a `Directory` that does not have an index path directly at that path. See\n`WithIndex` and `Directory.indexPath`.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"includes","comment":" Check if the `Directory` contains the `PagePath`. This can be useful\nfor styling a link in the navbar if you are in that folder. Note that\nthe `view` function gets passed the `currentPage` (`Pages.application` from\nyour generated `Pages.elm` module).\n\n    import Element exposing (Element)\n    import Element.Font as Font\n    import Pages.Directory as Directory exposing (Directory)\n\n    navbar : PagePath Pages.PathKey -> Element msg\n    navbar currentPage =\n        Element.row [ Element.spacing 15 ]\n            [ navbarLink currentPath pages.docs.directory \"Docs\"\n            , navbarLink currentPath pages.blog.directory \"Blog\"\n            ]\n\n    navbarLink :\n        PagePath Pages.PathKey\n        -> Directory Pages.PathKey Directory.WithIndex\n        -> String\n        -> Element msg\n    navbarLink currentPath linkDirectory displayName =\n        let\n            isHighlighted =\n                currentPath |> Directory.includes linkDirectory\n        in\n        Element.link\n            (if isHighlighted then\n                [ Font.underline\n                , Font.color Palette.color.primary\n                ]\n\n             else\n                []\n            )\n            { url = linkDirectory |> Directory.indexPath |> PagePath.toString\n            , label = Element.text displayName\n            }\n\n","type":"Pages.Directory.Directory key hasIndex -> Pages.PagePath.PagePath key -> Basics.Bool"},{"name":"indexPath","comment":" Get the `PagePath` for the given Directory.\n\n    import Pages\n    import Pages.Directory as Directory exposing (Directory)\n\n    blogDirectory : Directory Pages.PathKey Directory.WithIndex\n    blogDirectory =\n        Pages.pages.blog.directory\n\n    -- blogDirectory |> Directory.indexPath |> PagePath.toString\n    -- => \"/blog\"\n\nSee `Directory.includes` for an example of this in action.\n\n","type":"Pages.Directory.Directory key Pages.Directory.WithIndex -> Pages.PagePath.PagePath key"},{"name":"withIndex","comment":" Used by the generated `Pages.elm` module. There's no need to use this\noutside of the generated code.\n","type":"key -> List.List (Pages.PagePath.PagePath key) -> List.List String.String -> Pages.Directory.Directory key Pages.Directory.WithIndex"},{"name":"withoutIndex","comment":" Used by the generated `Pages.elm` module. There's no need to use this\noutside of the generated code.\n","type":"key -> List.List (Pages.PagePath.PagePath key) -> List.List String.String -> Pages.Directory.Directory key Pages.Directory.WithoutIndex"}],"binops":[]},{"name":"Pages.Document","comment":" The `Document` represents all the ways to handle the frontmatter metadata\nand documents found in your `content` folder.\n\nFrontmatter content is turned into JSON, so you can use the familiar Elm JSON decoding\nto get frontmatter content. And you'll get helpful error messages if any of\nyour frontmatter is invalid (which will prevent an invalid production build from\nbeing created!).\n\nIt's up to you how you parse your metadata and content. Here's a simple example of\na site that has two types of pages, `blog` posts and `page` (a regular page like `/about` or `/`).\n\n`content/index.md`\n\n```markdown\n---\ntype: page\ntitle: Welcome to my site!\n---\n# Here's my site!\n\nI built it with `elm-pages`! ðŸš€\n```\n\n`content/blog/hello-world.md`\n\n```markdown\n---\ntype: blog\nauthor: Dillon Kearns\ntitle: Hello, World!\n---\n# Hello, World! ðŸ‘‹\n\n## This will be parsed as markdown\n\nHello!!!\n```\n\n    -- this example uses elm-explorations/markdown\n\n\n    import Html exposing (Html)\n    import Json.Decode as Decode exposing (Decoder)\n    import Markdown\n    import Pages.Document\n\n    type Metadata\n        = Blog { title : String, description : String, author : String }\n        | Page { title : String }\n\n    markdownDocument : ( String, Pages.Document.DocumentHandler Metadata (Html msg) )\n    markdownDocument =\n        Pages.Document.parser\n            { extension = \"md\"\n            , metadata = frontmatterDecoder\n            , body = Markdown.toHtml []\n            }\n\n    frontmatterDecoder : Decoder Metadata\n    frontmatterDecoder =\n        Decode.field \"type\" Decode.string\n            |> Decode.andThen\n                (\\metadataType ->\n                    case metadataType of\n                        \"blog\" ->\n                            Decode.map3 (\\title description author -> { title = title, description = description, author = author })\n                                (Decode.field \"title\" Decode.string)\n                                (Decode.field \"description\" Decode.string)\n                                (Decode.field \"author\" Decode.string)\n\n                        \"page\" ->\n                            Decode.map (\\title -> { title = title })\n                                (Decode.field \"title\" Decode.string)\n                )\n\n@docs Document, DocumentHandler\n@docs parser, markupParser\n\n\n## Functions for use by generated code\n\n@docs fromList, get\n\n","unions":[{"name":"Document","comment":" Represents all of the `DocumentHandler`s. You register a handler for each\nextension that tells it how to parse frontmatter and content for that extension.\n","args":["metadata","view"],"cases":[]},{"name":"DocumentHandler","comment":" How to parse the frontmatter and content for a given extension. Build one\nusing `Document.parser` (see above for an example).\n","args":["metadata","view"],"cases":[]}],"aliases":[],"values":[{"name":"fromList","comment":" Used by the generated `Pages.elm` module. There's no need to use this\noutside of the generated code.\n","type":"List.List ( String.String, Pages.Document.DocumentHandler metadata view ) -> Pages.Document.Document metadata view"},{"name":"get","comment":" Used by the generated `Pages.elm` module. There's no need to use this\noutside of the generated code.\n","type":"String.String -> Pages.Document.Document metadata view -> Maybe.Maybe { frontmatterParser : String.String -> Result.Result String.String metadata, contentParser : String.String -> Result.Result String.String view }"},{"name":"markupParser","comment":" Register an [`elm-markup`](https://github.com/mdgriffith/elm-markup/)\nparser for your `.emu` files.\n","type":"Mark.Document metadata -> Mark.Document view -> ( String.String, Pages.Document.DocumentHandler metadata view )"},{"name":"parser","comment":" Create a Document Handler for the given extension.\n","type":"{ extension : String.String, metadata : Json.Decode.Decoder metadata, body : String.String -> Result.Result String.String view } -> ( String.String, Pages.Document.DocumentHandler metadata view )"}],"binops":[]},{"name":"Pages.ImagePath","comment":" This module is analgous to `Pages.PagePath`, except it represents an\nImage Path rather than a Page Path. Rather than copy-pasting those docs, I'll\nnote the differences here. See the `Pages.PagePath` docs for more background.\n\n\n## Record-based `PagePath` lookup\n\nYou can lookup a specific static image path based on its path using the record-based lookup:\n\n    Pages.images\n\nThis gives you a record, based on all the files in your local\n`images` directory, that lets you look paths up like so:\n\n    import Pages\n    import Pages.ImagePath as ImagePath exposing (ImagePath)\n\n    homePath : ImagePath Pages.PathKey\n    homePath =\n        Pages.pages.index\n\n    -- ImagePath.toString homePath\n    -- => \"/\"\n\nor\n\n    import Pages\n    import Pages.ImagePath as ImagePath exposing (ImagePath)\n\n    dillonProfilePhoto : ImagePath Pages.PathKey\n    dillonProfilePhoto =\n        Pages.images.profilePhotos.dillon\n\n    -- ImagePath.toString helloWorldPostPath\n    -- => \"/images/profile-photos/dillon.jpg\"\n\n@docs ImagePath, toString, external\n\n\n## Functions for code generation only\n\nDon't bother using these.\n\n@docs build\n\n","unions":[{"name":"ImagePath","comment":" There are only two ways to get an `ImagePath`:\n\n1.  Get a value using the generated `Pages.elm` module in your repo (see above), or\n2.  Generate an external route using `PagePath.external`.\n\nSo `ImagePath` represents either a 1) known, static image asset path, or 2) an\nexternal image path (which is not validated so use these carefully!).\n\n","args":["key"],"cases":[]}],"aliases":[],"values":[{"name":"build","comment":" This is not useful except for the internal generated code to construct an `ImagePath`.\n","type":"key -> List.List String.String -> Pages.ImagePath.ImagePath key"},{"name":"external","comment":" This allows you to build a URL to an external resource. Avoid using\n`ImagePath.external` to refer to statically available image resources. Instead, use\nthis only to point to outside images.\n\n    import Pages\n    import Pages.ImagePath as ImagePath exposing (ImagePath)\n\n\n    -- The `Pages` module is generated in your codebase.\n    -- Notice that we can still annotate this external image\n    -- with `Pages.PathKey`, since external images are always valid\n    -- (unlike internal images, which are guaranteed to be present\n    -- if your code compiles).\n    benchmarkImagePath : ImagePath Pages.PathKey\n    benchmarkImagePath =\n        PagePath.external \"https://elm-lang.org/assets/home/benchmark.png\"\n\n    -- ImagePath.toString benchmarkImagePath\n    -- => \"https://elm-lang.org/assets/home/benchmark.png\"\n\n","type":"String.String -> Pages.ImagePath.ImagePath key"},{"name":"toString","comment":" Gives you the image's absolute URL as a String. This is useful for constructing `<img>` tags:\n\n    import Html exposing (Html, img)\n    import Html.Attributes exposing (src)\n    import Pages\n    import Pages.ImagePath as ImagePath exposing (ImagePath)\n\n\n    -- `Pages` is a generated module\n    logoImagePath : ImagePath Pages.PathKey\n    logoImagePath =\n        Pages.pages.index\n\n    linkToHome : Html msg\n    linkToHome =\n        img [ src (ImagePath.toString logoImagePath) ] []\n\n","type":"Pages.ImagePath.ImagePath key -> String.String"}],"binops":[]},{"name":"Pages.Internal","comment":" You don't need to use this unless you want to play around with the internals of `elm-pages` to build\na similar framework and hook into the low-level details. Otherwise, just grab the `Pages.Internal.Internal` value\nthat is in the generated `Pages` module (see <Pages.Platform>).\n\n@docs Internal\n\n@docs ApplicationType\n\n","unions":[{"name":"ApplicationType","comment":" Internal detial to track whether to run the CLI step or the runtime step in the browser.\n","args":[],"cases":[["Browser",[]],["Cli",[]]]}],"aliases":[{"name":"Internal","comment":" This type is generated for you in your `gen/Pages.elm` module (see <Pages.Platform>).\n","args":["pathKey"],"type":"{ applicationType : Pages.Internal.ApplicationType, content : Pages.Internal.Platform.Content, pathKey : pathKey, toJsPort : Json.Encode.Value -> Platform.Cmd.Cmd Basics.Never }"}],"values":[],"binops":[]},{"name":"Pages.Manifest","comment":" Represents the configuration of a\n[web manifest file](https://developer.mozilla.org/en-US/docs/Web/Manifest).\n\nYou pass your `Pages.Manifest.Config` record into the `Pages.application` function\n(from your generated `Pages.elm` file).\n\n    import Pages\n    import Pages.Manifest as Manifest\n    import Pages.Manifest.Category\n    import Pages.PagePath as PagePath exposing (PagePath)\n    import Palette\n\n    manifest : Manifest.Config Pages.PathKey\n    manifest =\n        { backgroundColor = Just Color.white\n        , categories = [ Pages.Manifest.Category.education ]\n        , displayMode = Manifest.Standalone\n        , orientation = Manifest.Portrait\n        , description = \"elm-pages - A statically typed site generator.\"\n        , iarcRatingId = Nothing\n        , name = \"elm-pages docs\"\n        , themeColor = Just Color.white\n        , startUrl = Pages.pages.index\n        , shortName = Just \"elm-pages\"\n        , sourceIcon = Pages.images.icon\n        }\n\n    main : Pages.Program Model Msg Metadata (List (Element Msg))\n    main =\n        Pages.application\n            { init = init\n            , view = view\n            , update = update\n            , subscriptions = subscriptions\n            , documents = [ markdownDocument ]\n            , head = head\n            , manifest = manifest\n            , canonicalSiteUrl = canonicalSiteUrl\n            }\n\n@docs Config\n\n\n## Config options\n\n@docs DisplayMode, Orientation\n\n\n## Functions for use by the generated code (`Pages.elm`)\n\n@docs toJson\n\n","unions":[{"name":"DisplayMode","comment":" See <https://developer.mozilla.org/en-US/docs/Web/Manifest/display>\n","args":[],"cases":[["Fullscreen",[]],["Standalone",[]],["MinimalUi",[]],["Browser",[]]]},{"name":"Orientation","comment":" <https://developer.mozilla.org/en-US/docs/Web/Manifest/orientation>\n","args":[],"cases":[["Any",[]],["Natural",[]],["Landscape",[]],["LandscapePrimary",[]],["LandscapeSecondary",[]],["Portrait",[]],["PortraitPrimary",[]],["PortraitSecondary",[]]]}],"aliases":[{"name":"Config","comment":" Represents a [web app manifest file](https://developer.mozilla.org/en-US/docs/Web/Manifest)\n(see above for how to use it).\n\nThe `sourceIcon` is used to automatically generate all of the Favicons and manifest\nicons of the appropriate sizes (512x512, etc) for Android, iOS, etc. So you just\npoint at a single image asset and you will have optimized images following all\nthe best practices!\n\n\n## Type-safe static paths\n\nThe `pathKey` in this type is used to ensure that you are using\nknown static resources for any internal image or page paths.\n\n  - The `startUrl` is a type-safe `PagePath`, ensuring that any internal links\n    are present (not broken links).\n  - The `sourceIcon` is a type-safe `ImagePath`, ensuring that any internal images\n    are present (not broken images).\n\n","args":["pathKey"],"type":"{ backgroundColor : Maybe.Maybe Color.Color, categories : List.List Pages.Manifest.Category.Category, displayMode : Pages.Manifest.DisplayMode, orientation : Pages.Manifest.Orientation, description : String.String, iarcRatingId : Maybe.Maybe String.String, name : String.String, themeColor : Maybe.Maybe Color.Color, startUrl : Pages.PagePath.PagePath pathKey, shortName : Maybe.Maybe String.String, sourceIcon : Pages.ImagePath.ImagePath pathKey }"}],"values":[{"name":"toJson","comment":" Feel free to use this, but in 99% of cases you won't need it. The generated\ncode will run this for you to generate your `manifest.json` file automatically!\n","type":"Pages.Manifest.Config pathKey -> Json.Encode.Value"}],"binops":[]},{"name":"Pages.Manifest.Category","comment":" See <https://github.com/w3c/manifest/wiki/Categories> and\n<https://developer.mozilla.org/en-US/docs/Web/Manifest/categories>\n\n@docs toString, Category\n\n@docs books, business, education, entertainment, finance, fitness, food, games, government, health, kids, lifestyle, magazines, medical, music, navigation, news, personalization, photo, politics, productivity, security, shopping, social, sports, travel, utilities, weather\n\n\n## Custom categories\n\n@docs custom\n\n","unions":[{"name":"Category","comment":" Represents a known, valid category, as specified by\n<https://github.com/w3c/manifest/wiki/Categories>. If this document is updated\nand I don't add it, please open an issue or pull request to let me know!\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"books","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"business","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"custom","comment":" It's best to use the pre-defined categories to ensure that clients (Android, iOS,\nChrome, Windows app store, etc.) are aware of it and can handle it appropriately.\nBut, if you're confident about using a custom one, you can do so with `Pages.Manifest.custom`.\n","type":"String.String -> Pages.Manifest.Category.Category"},{"name":"education","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"entertainment","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"finance","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"fitness","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"food","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"games","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"government","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"health","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"kids","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"lifestyle","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"magazines","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"medical","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"music","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"navigation","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"news","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"personalization","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"photo","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"politics","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"productivity","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"security","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"shopping","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"social","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"sports","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"toString","comment":" Turn a category into its official String representation, as seen\nhere: <https://github.com/w3c/manifest/wiki/Categories>.\n","type":"Pages.Manifest.Category.Category -> String.String"},{"name":"travel","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"utilities","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"weather","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"}],"binops":[]},{"name":"Pages.PagePath","comment":" You can get data representing type-safe, guaranteed-available\nroutes from your generated `Pages` module in your repo. If the file\nis not available, make sure you've run `elm-pages develop`.\n\nThe `key` in the `PagePath key` type protects you from using\na route that is not from the static routes that the generated\n`Pages.elm` module provides. That means that if you use one of these values,\nyou can completely trust it and get helpful compiler errors if you mispell something\nor access a dead link!\n\nThe static `PagePath`s for your site are generated so you can grab them in\ntwo ways:\n\n\n## List-based `PagePath` lookup\n\nYou will find a list of all the pages in your app in this generated code:\n\n    Pages.allPages : List (PagePath Pages.PathKey)\n\nThis is handy for creating an index page, for example showing all\nthe blog posts in your site.\n\n\n## Record-based `PagePath` lookup\n\nYou can lookup a specific static route based on its path using the record-based lookup:\n\n    Pages.pages\n\nThis gives you a record, based on your local `content` directory, that lets you look paths up like so:\n\n    import Pages\n    import Pages.PagePath as PagePath exposing (PagePath)\n\n    homePath : PagePath Pages.PathKey\n    homePath =\n        Pages.pages.index\n\n    -- PagePath.toString homePath\n    -- => \"/\"\n\nor\n\n    import Pages\n    import Pages.PagePath as PagePath exposing (PagePath)\n\n    helloWorldPostPath : PagePath Pages.PathKey\n    helloWorldPostPath =\n        Pages.pages.blog.helloWorld\n\n    -- PagePath.toString helloWorldPostPath\n    -- => \"/blog/hello-world\"\n\nNote that in the `hello-world` example it changes from the kebab casing of the actual\nURL to camelCasing for the record key.\n\nThis is useful for referring to static routes directly from your Elm code (you'll\nneed a different technique for verifying that a link in your markup content\nis valid).\n\nFor example, you might have a navbar that links to specific routes.\n\n@docs PagePath, toString, external\n\n\n## Functions for code generation only\n\nDon't bother using these.\n\n@docs build\n\n","unions":[{"name":"PagePath","comment":" There are only two ways to get a `PagePath`:\n\n1.  Get a value using the generated `Pages.elm` module in your repo (see above), or\n2.  Generate an external route using `PagePath.external`.\n\nSo `PagePath` represents either a 1) known, static page path, or 2) an\nexternal page path (which is not validated so use these carefully!).\n\n","args":["key"],"cases":[]}],"aliases":[],"values":[{"name":"build","comment":" This is not useful except for the internal generated code to construct a PagePath.\n","type":"key -> List.List String.String -> Pages.PagePath.PagePath key"},{"name":"external","comment":" This allows you to build a URL to an external resource. Avoid using\n`PagePath.external` to refer to statically available routes. Instead, use\nthis only to point to outside pages.\n\n    import Pages\n    import Pages.PagePath as PagePath exposing (PagePath)\n\n\n    -- The `Pages` module is generated in your codebase.\n    -- Notice that we can still annotate this external link\n    -- with `Pages.PathKey`, since external links are always valid\n    -- (unlike internal routes, which are guaranteed to be present\n    -- if your code compiles).\n    googlePath : PagePath Pages.PathKey\n    googlePath =\n        PagePath.external \"https://google.com\"\n\n","type":"String.String -> Pages.PagePath.PagePath key"},{"name":"toString","comment":" Gives you the page's absolute URL as a String. This is useful for constructing links:\n\n    import Html exposing (Html, a)\n    import Html.Attributes exposing (href)\n    import Pages\n    import Pages.PagePath as PagePath exposing (PagePath)\n\n\n    -- `Pages` is a generated module\n    homePath : PagePath Pages.PathKey\n    homePath =\n        Pages.pages.index\n\n    linkToHome : Html msg\n    linkToHome =\n        a [ href (PagePath.toString homePath) ] [ text \"ðŸ¡ Home\" ]\n\n","type":"Pages.PagePath.PagePath key -> String.String"}],"binops":[]},{"name":"Pages.Platform","comment":" Configure your `elm-pages` Program, similar to a `Browser.application`.\n\n@docs application, Program, Page\n\n","unions":[],"aliases":[{"name":"Page","comment":" ","args":["metadata","view","pathKey"],"type":"{ metadata : metadata, path : Pages.PagePath.PagePath pathKey, view : view }"},{"name":"Program","comment":" The `Program` type for an `elm-pages` app.\n","args":["model","msg","metadata","view"],"type":"Pages.Internal.Platform.Program model msg metadata view"}],"values":[{"name":"application","comment":" This is the entry point for your `elm-pages` application.\n\nThis is similar to how you set up a regular Elm application using `Browser.application`, but with a few differences.\n\n  - `view` has access to `StaticHttp` data (see [Pages.StaticHttp](#Pages.StaticHttp)).\n  - `view` is able to set `head` tags which can be used for site metadata and SEO data.\n  - `manifest` lets you configure the manifest.json for your PWA (Progressive Web App).\n  - `canonicalSiteUrl` is the default domain for your `<head>` tags for SEO purposes (you can override it with `canonicalUrlOverride`,\n    see <Head.Seo>. Learn more about canonical URLs and why they are important [in this article](https://yoast.com/rel-canonical/).\n  - `internals` is an opaque data type with some internal boilerplate from your `elm-pages` content. You should pass it `internals = Pages.internals`.\n\nOtherwise, you have a standard Elm app which\n\n\n## `elm-pages` Lifecycle\n\nIt's helpful to understand the `elm-pages` lifecycle and how it compares to a vanilla elm app (i.e. a `Browser.application`).\n\n\n### Generate Step (`elm-pages build`)\n\nWhereas a vanilla Elm app simply compiles your Elm code at build time, `elm-pages` performs some lifecycle events at this stage.\n\n  - Performs all `StaticHttp.Request`s (see <Pages.StaticHttp>) for every static page in your app. The StaticHttp Responses are stored in JSON\n    files called `content.json` (one JSON file for each static page in your site).\n  - Pre-renders HTML pages, including the `<head>` tags for the page from your `view`'s `head`.\n  - Optimizes image assets and copies over files from `static` folder to the `dist` folder.\n\n\n### Initial Load (from user's browser)\n\nThe user will see the pre-rendered HTML when they initially load a page on your `elm-pages` site (unless you are in dev mode, i.e. `elm-pages develop`, in\nwhich case there is no pre-rendering).\n\n\n### Hydration\n\n  - Fetch all the `StaticHttp` responses and page data (the `content.json` file for the current page).\n  - The Elm app hydrates and starts executing and running your Elm app's `init` function and `update` loop (not just the pre-rendered HTML content).\n    At this point, all of your `subscriptions`, etc. will behave as they would in a regular Elm application.\n  - The app will now run as a single-page app. When you hover over a link to another static page on your current site,\n    it will pre-fetch the page data (`content.json` file), so that the page load is instant.\n\n","type":"{ init : Maybe.Maybe { path : Pages.PagePath.PagePath pathKey, query : Maybe.Maybe String.String, fragment : Maybe.Maybe String.String } -> ( userModel, Platform.Cmd.Cmd userMsg ), update : userMsg -> userModel -> ( userModel, Platform.Cmd.Cmd userMsg ), subscriptions : userModel -> Platform.Sub.Sub userMsg, view : List.List ( Pages.PagePath.PagePath pathKey, metadata ) -> { path : Pages.PagePath.PagePath pathKey, frontmatter : metadata } -> Pages.StaticHttp.Request { view : userModel -> view -> { title : String.String, body : Html.Html userMsg }, head : List.List (Head.Tag pathKey) }, documents : List.List ( String.String, Pages.Document.DocumentHandler metadata view ), manifest : Pages.Manifest.Config pathKey, generateFiles : List.List { path : Pages.PagePath.PagePath pathKey, frontmatter : metadata, body : String.String } -> List.List (Result.Result String.String { path : List.List String.String, content : String.String }), onPageChange : { path : Pages.PagePath.PagePath pathKey, query : Maybe.Maybe String.String, fragment : Maybe.Maybe String.String } -> userMsg, canonicalSiteUrl : String.String, internals : Pages.Internal.Internal pathKey } -> Pages.Platform.Program userModel userMsg metadata view"}],"binops":[]},{"name":"Pages.Secrets","comment":" Secrets are a secure way to use environment variables in your StaticHttp requests. The actual environment\nvariable value is used to perform StaticHttp requests, while the masked value is the only thing that ends up in your\nbuilt site. Let's go through what happens in a concrete example:\n\n\n## Example\n\nLet's say you execute this from the shell:\n\n```shell\nGITHUB_TOKEN=abcd1234 API_KEY=xyz789 elm-pages build\n```\n\nAnd your StaticHttp request in your Elm code looks like this:\n\n    import Pages.Secrets as Secrets\n    import Pages.StaticHttp as StaticHttp\n\n    StaticHttp.request\n        (Secrets.succeed\n            (\\githubToken stripeoken ->\n                { url = \"https://api.github.com/repos/dillonkearns/elm-pages?apiKey=\" ++ apiKey\n                , method = \"GET\"\n                , headers = [ ( \"Authorization\", \"Bearer \" ++ bearer ) ]\n                }\n            )\n            |> Secrets.with \"API_KEY\"\n            |> Secrets.with \"BEARER\"\n        )\n        (Decode.succeed ())\n    )\n\nThe following masked values are what will be visible in your production bundle if you inspect the code or the Network tab:\n\n    [GET]https://api.github.com/repos/dillonkearns/elm-pages?apiKey=<API_KEY>Authorization : Bearer <BEARER>\n\nSo the actual Secrets only exist for the duration of the build in order to perform the StaticHttp requests, but they\nare replaced with `<SECRET_NAME>` once that step is done and your assets are bundled.\n\n@docs Value, map, succeed, with\n\n","unions":[],"aliases":[{"name":"Value","comment":" Represents a Secure value from your environment variables. `Pages.Secrets.Value`s are much like `Json.Decode.Value`s\nin that you can take raw values, map them, and combine them with other values into any data structure.\n","args":["value"],"type":"Secrets.Value value"}],"values":[{"name":"map","comment":" Map a Secret's raw value into an arbitrary type or value.\n","type":"(valueA -> valueB) -> Pages.Secrets.Value valueA -> Pages.Secrets.Value valueB"},{"name":"succeed","comment":" Hardcode a secret value. Or, this can be used to start a pipeline-style value with several different secrets (see\nthe example at the top of this page).\n\n    import Pages.Secrets as Secrets\n\n    Secrets.succeed \"hardcoded-secret\"\n\n","type":"value -> Pages.Secrets.Value value"},{"name":"with","comment":" Allows you to chain together multiple secrets. See the top of this page for a full example.\n","type":"String.String -> Pages.Secrets.Value (String.String -> value) -> Pages.Secrets.Value value"}],"binops":[]},{"name":"Pages.StaticHttp","comment":" StaticHttp requests are an alternative to doing Elm HTTP requests the traditional way using the `elm/http` package.\n\nThe key differences are:\n\n  - `StaticHttp.Request`s are performed once at build time (`Http.Request`s are performed at runtime, at whenever point you perform them)\n  - `StaticHttp.Request`s strip out unused JSON data from the data your decoder doesn't touch to minimize the JSON payload\n  - `StaticHttp.Request`s can use [`Pages.Secrets`](Pages.Secrets) to securely use credentials from your environemnt variables which are completely masked in the production assets.\n  - `StaticHttp.Request`s have a built-in `StaticHttp.andThen` that allows you to perform follow-up requests without using tasks\n\n\n## Scenarios where StaticHttp is a good fit\n\nIf you need data that is refreshed often you may want to do a traditional HTTP request with the `elm/http` package.\nThe kinds of situations that are served well by static HTTP are with data that updates moderately frequently or infrequently (or never).\nA common pattern is to trigger a new build when data changes. Many JAMstack services\nallow you to send a WebHook to your host (for example, Netlify is a good static file host that supports triggering builds with webhooks). So\nyou may want to have your site rebuild everytime your calendar feed has an event added, or whenever a page or article is added\nor updated on a CMS service like Contentful.\n\nIn scenarios like this, you can serve data that is just as up-to-date as it would be using `elm/http`, but you get the performance\ngains of using `StaticHttp.Request`s as well as the simplicity and robustness that comes with it. Read more about these benefits\nin [this article introducing StaticHttp requests and some concepts around it](https://elm-pages.com/blog/static-http).\n\n\n## Scenarios where StaticHttp is not a good fit\n\n  - Data that is specific to the logged-in user\n  - Data that needs to be the very latest and changes often (for example, sports scores)\n\n@docs Request, RequestDetails\n@docs get, request\n@docs map, succeed\n\n\n## Building a StaticHttp Request Body\n\nThe way you build a body is analagous to the `elm/http` package. Currently, only `emptyBody` and\n`stringBody` are supported. If you have a use case that calls for a different body type, please open a Github issue\nand describe your use case!\n\n@docs Body, emptyBody, stringBody\n\n\n## Chaining Requests\n\n@docs andThen, resolve, combine\n\n@docs map2, map3, map4, map5, map6, map7, map8, map9\n\n\n## Unoptimized Requests\n\nWarning - use these at your own risk! It's highly recommended that you use the other request functions that make use of\n`zwilias/json-decode-exploration` in order to allow you to reduce down your JSON to only the values that are used by\nyour decoders. This can significantly reduce download sizes for your StaticHttp requests.\n\n@docs unoptimizedRequest\n\n\n### Expect for unoptimized requests\n\n@docs Expect, expectString, expectUnoptimizedJson\n\n","unions":[{"name":"Expect","comment":" Analgous to the `Expect` type in the `elm/http` package. This represents how you will process the data that comes\nback in your StaticHttp request.\n\nYou can derive `ExpectUnoptimizedJson` from `ExpectString`. Or you could build your own helper to process the String\nas XML, for example, or give an `elm-pages` build error if the response can't be parsed as XML.\n\n","args":["value"],"cases":[]}],"aliases":[{"name":"Body","comment":" A body for a StaticHttp request.\n","args":[],"type":"Pages.Internal.StaticHttpBody.Body"},{"name":"Request","comment":" A Request that will be made a build time. Multiple `StaticHttp.Request`s can be combined together using the `mapN` functions,\nvery similar to how you can manipulate values with Json Decoders in Elm.\n","args":["value"],"type":"Pages.StaticHttpRequest.Request value"},{"name":"RequestDetails","comment":" The full details to perform a StaticHttp request.\n","args":[],"type":"{ url : String.String, method : String.String, headers : List.List ( String.String, String.String ), body : Pages.StaticHttp.Body }"}],"values":[{"name":"andThen","comment":" Build off of the response from a previous `StaticHttp` request to build a follow-up request. You can use the data\nfrom the previous response to build up the URL, headers, etc. that you send to the subsequent request.\n\n    import Json.Decode as Decode exposing (Decoder)\n    import Pages.StaticHttp as StaticHttp\n\n    licenseData : StaticHttp.Request String\n    licenseData =\n        StaticHttp.get\n            (Secrets.succeed \"https://api.github.com/repos/dillonkearns/elm-pages\")\n            (Decode.at [ \"license\", \"url\" ] Decode.string)\n            |> StaticHttp.andThen\n                (\\licenseUrl ->\n                    StaticHttp.get (Secrets.succeed licenseUrl) (Decode.field \"description\" Decode.string)\n                )\n\n","type":"(a -> Pages.StaticHttp.Request b) -> Pages.StaticHttp.Request a -> Pages.StaticHttp.Request b"},{"name":"combine","comment":" Turn a list of `StaticHttp.Request`s into a single one.\n\n    import Json.Decode as Decode exposing (Decoder)\n    import Pages.StaticHttp as StaticHttp\n\n    type alias Pokemon =\n        { name : String\n        , sprite : String\n        }\n\n    pokemonDetailRequest : StaticHttp.Request (List Pokemon)\n    pokemonDetailRequest =\n        StaticHttp.get\n            (Secrets.succeed \"https://pokeapi.co/api/v2/pokemon/?limit=3\")\n            (Decode.field \"results\"\n                (Decode.list\n                    (Decode.map2 Tuple.pair\n                        (Decode.field \"name\" Decode.string)\n                        (Decode.field \"url\" Decode.string)\n                        |> Decode.map\n                            (\\( name, url ) ->\n                                StaticHttp.get (Secrets.succeed url)\n                                    (Decode.at\n                                        [ \"sprites\", \"front_default\" ]\n                                        Decode.string\n                                        |> Decode.map (Pokemon name)\n                                    )\n                            )\n                    )\n                )\n            )\n            |> StaticHttp.andThen StaticHttp.combine\n\n","type":"List.List (Pages.StaticHttp.Request value) -> Pages.StaticHttp.Request (List.List value)"},{"name":"emptyBody","comment":" Build an empty body for a StaticHttp request. See [elm/http's `Http.emptyBody`](https://package.elm-lang.org/packages/elm/http/latest/Http#emptyBody).\n","type":"Pages.StaticHttp.Body"},{"name":"expectString","comment":" Request a raw String. You can validate the String if you need to check the formatting, or try to parse it\nin something besides JSON. Be sure to use the `StaticHttp.request` function if you want an optimized request that\nstrips out unused JSON to optimize your asset size.\n\nIf the function you pass to `expectString` yields an `Err`, then you will get at StaticHttpDecodingError that will\nfail your `elm-pages` build and print out the String from the `Err`.\n\n    request =\n        StaticHttp.unoptimizedRequest\n            (Secrets.succeed\n                { url = \"https://example.com/file.txt\"\n                , method = \"GET\"\n                , headers = []\n                , body = StaticHttp.emptyBody\n                }\n            )\n            (StaticHttp.expectString\n                (\\string ->\n                    if String.toUpper string == string then\n                        Ok string\n\n                    else\n                        Err \"String was not uppercased\"\n                )\n            )\n\n","type":"(String.String -> Result.Result String.String value) -> Pages.StaticHttp.Expect value"},{"name":"expectUnoptimizedJson","comment":" Handle the incoming response as JSON and don't optimize the asset and strip out unused values.\nBe sure to use the `StaticHttp.request` function if you want an optimized request that\nstrips out unused JSON to optimize your asset size. This function makes sense to use for things like a GraphQL request\nwhere the JSON payload is already trimmed down to the data you explicitly requested.\n\nIf the function you pass to `expectString` yields an `Err`, then you will get at StaticHttpDecodingError that will\nfail your `elm-pages` build and print out the String from the `Err`.\n\n","type":"Json.Decode.Decoder value -> Pages.StaticHttp.Expect value"},{"name":"get","comment":" A simplified helper around [`StaticHttp.request`](#request), which builds up a StaticHttp GET request.\n\n    import Json.Decode as Decode exposing (Decoder)\n    import Pages.StaticHttp as StaticHttp\n\n    getRequest : StaticHttp.Request Int\n    getRequest =\n        StaticHttp.get \"https://api.github.com/repos/dillonkearns/elm-pages\"\n            (Decode.field \"stargazers_count\" Decode.int)\n\n","type":"Pages.Secrets.Value String.String -> Json.Decode.Exploration.Decoder a -> Pages.StaticHttp.Request a"},{"name":"map","comment":" Transform a request into an arbitrary value. The same underlying HTTP requests will be performed during the build\nstep, but mapping allows you to change the resulting values by applying functions to the results.\n\nA common use for this is to map your data into your elm-pages view:\n\n    import Json.Decode as Decode exposing (Decoder)\n    import Pages.StaticHttp as StaticHttp\n\n    view =\n        StaticHttp.get \"https://api.github.com/repos/dillonkearns/elm-pages\"\n            (Decode.field \"stargazers_count\" Decode.int)\n            |> StaticHttp.map\n                (\\stars ->\n                    { view =\n                        \\model viewForPage ->\n                            { title = \"Current stars: \" ++ String.fromInt stars\n                            , body = Html.text <| \"â­ï¸ \" ++ String.fromInt stars\n                            , head = []\n                            }\n                    }\n                )\n\n","type":"(a -> b) -> Pages.StaticHttp.Request a -> Pages.StaticHttp.Request b"},{"name":"map2","comment":" Like map, but it takes in two `Request`s.\n\n    view siteMetadata page =\n        StaticHttp.map2\n            (\\elmPagesStars elmMarkdownStars ->\n                { view =\n                    \\model viewForPage ->\n                        { title = \"Repo Stargazers\"\n                        , body = starsView elmPagesStars elmMarkdownStars\n                        }\n                , head = head elmPagesStars elmMarkdownStars\n                }\n            )\n            (get \"https://api.github.com/repos/dillonkearns/elm-pages\"\n                (Decode.field \"stargazers_count\" Decode.int)\n            )\n            (get \"https://api.github.com/repos/dillonkearns/elm-markdown\"\n                (Decode.field \"stargazers_count\" Decode.int)\n            )\n\n","type":"(a -> b -> c) -> Pages.StaticHttp.Request a -> Pages.StaticHttp.Request b -> Pages.StaticHttp.Request c"},{"name":"map3","comment":" ","type":"(value1 -> value2 -> value3 -> valueCombined) -> Pages.StaticHttp.Request value1 -> Pages.StaticHttp.Request value2 -> Pages.StaticHttp.Request value3 -> Pages.StaticHttp.Request valueCombined"},{"name":"map4","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> valueCombined) -> Pages.StaticHttp.Request value1 -> Pages.StaticHttp.Request value2 -> Pages.StaticHttp.Request value3 -> Pages.StaticHttp.Request value4 -> Pages.StaticHttp.Request valueCombined"},{"name":"map5","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> valueCombined) -> Pages.StaticHttp.Request value1 -> Pages.StaticHttp.Request value2 -> Pages.StaticHttp.Request value3 -> Pages.StaticHttp.Request value4 -> Pages.StaticHttp.Request value5 -> Pages.StaticHttp.Request valueCombined"},{"name":"map6","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> valueCombined) -> Pages.StaticHttp.Request value1 -> Pages.StaticHttp.Request value2 -> Pages.StaticHttp.Request value3 -> Pages.StaticHttp.Request value4 -> Pages.StaticHttp.Request value5 -> Pages.StaticHttp.Request value6 -> Pages.StaticHttp.Request valueCombined"},{"name":"map7","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> valueCombined) -> Pages.StaticHttp.Request value1 -> Pages.StaticHttp.Request value2 -> Pages.StaticHttp.Request value3 -> Pages.StaticHttp.Request value4 -> Pages.StaticHttp.Request value5 -> Pages.StaticHttp.Request value6 -> Pages.StaticHttp.Request value7 -> Pages.StaticHttp.Request valueCombined"},{"name":"map8","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> value8 -> valueCombined) -> Pages.StaticHttp.Request value1 -> Pages.StaticHttp.Request value2 -> Pages.StaticHttp.Request value3 -> Pages.StaticHttp.Request value4 -> Pages.StaticHttp.Request value5 -> Pages.StaticHttp.Request value6 -> Pages.StaticHttp.Request value7 -> Pages.StaticHttp.Request value8 -> Pages.StaticHttp.Request valueCombined"},{"name":"map9","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> value8 -> value9 -> valueCombined) -> Pages.StaticHttp.Request value1 -> Pages.StaticHttp.Request value2 -> Pages.StaticHttp.Request value3 -> Pages.StaticHttp.Request value4 -> Pages.StaticHttp.Request value5 -> Pages.StaticHttp.Request value6 -> Pages.StaticHttp.Request value7 -> Pages.StaticHttp.Request value8 -> Pages.StaticHttp.Request value9 -> Pages.StaticHttp.Request valueCombined"},{"name":"request","comment":" Build a `StaticHttp` request (analagous to [Http.request](https://package.elm-lang.org/packages/elm/http/latest/Http#request)).\nThis function takes in all the details to build a `StaticHttp` request, but you can build your own simplified helper functions\nwith this as a low-level detail, or you can use functions like [StaticHttp.get](#get).\n","type":"Pages.Secrets.Value Pages.StaticHttp.RequestDetails -> Json.Decode.Exploration.Decoder a -> Pages.StaticHttp.Request a"},{"name":"resolve","comment":" Helper to remove an inner layer of Request wrapping.\n","type":"Pages.StaticHttp.Request (List.List (Pages.StaticHttp.Request value)) -> Pages.StaticHttp.Request (List.List value)"},{"name":"stringBody","comment":" Builds a string body for a StaticHttp request. See [elm/http's `Http.stringBody`](https://package.elm-lang.org/packages/elm/http/latest/Http#stringBody).\n","type":"String.String -> Pages.StaticHttp.Body"},{"name":"succeed","comment":" This is useful for prototyping with some hardcoded data, or for having a view that doesn't have any StaticHttp data.\n\n    import Pages.StaticHttp as StaticHttp\n\n    view :\n        List ( PagePath Pages.PathKey, Metadata )\n        ->\n            { path : PagePath Pages.PathKey\n            , frontmatter : Metadata\n            }\n        ->\n            StaticHttp.Request\n                { view : Model -> View -> { title : String, body : Html Msg }\n                , head : List (Head.Tag Pages.PathKey)\n                }\n    view siteMetadata page =\n        StaticHttp.succeed\n            { view =\n                \\model viewForPage ->\n                    mainView model viewForPage\n            , head = head page.frontmatter\n            }\n\n","type":"a -> Pages.StaticHttp.Request a"},{"name":"unoptimizedRequest","comment":" This is an alternative to the other request functions in this module that doesn't perform any optimizations on the\nasset. Be sure to use the optimized versions, like `StaticHttp.request`, if you can. Using those can significantly reduce\nyour asset sizes by removing all unused fields from your JSON.\n\nYou may want to use this function instead if you need XML data or plaintext. Or maybe you're hitting a GraphQL API,\nso you don't need any additional optimization as the payload is already reduced down to exactly what you requested.\n\n","type":"Pages.Secrets.Value Pages.StaticHttp.RequestDetails -> Pages.StaticHttp.Expect a -> Pages.StaticHttp.Request a"}],"binops":[]}]